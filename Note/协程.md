⼀个进程可以拥有多个线程，⼀个线程也，可以拥有多个协程，因此协程⼜称微线程和纤程。go中的协程与线程类似，但是其属于用户态，用户可控，线程属于内核态，用户不可控。系统对主线程和协程进行抢占式调度，默认情况下主线程不会等待协程运行完毕才退出，而是主线程结束直接结束协程

```go
package main  
  
import (  
    "fmt"  
    "time")  
  
func show(msg string) {  
    for i := 0; i < 5; i++ {  
       fmt.Println(msg)  
    }  
}  
  
func main() {  
    go show("hello")  
    time.Sleep(1 * time.Second)  
    show("hello world")  
  
}
```

# 通道
通道用于并发执行时，goroutine之间的资源共享，通道分为无缓冲通道和缓冲通道，无缓冲通道用于同步通信，而缓冲通道用于异步通信
## 创建和使用通道

```go
//无缓冲整型通道
ch := make(chan int)  
//缓冲通道
ints := make(chan int, 5)
//使用
ch := make(chan int, 5)  
ch <- 1  
data := <-ch  
fmt.Println(data)
```

## 无缓冲实例

```go
ch := make(chan int)  
go func() {  
    fmt.Println("准备向通道写入")  
    ch <- 1  
    fmt.Println("写入完毕")  
}()  
fmt.Println("准备从通道读出")  
data := <-ch  
fmt.Println("读出完毕")  
fmt.Println(data)
//准备从通道读出  
//准备向通道写入  
//写入完毕  
//读出完毕  
//1

```

## 缓存实例

```go
ch := make(chan int, 1)  
defer close(ch)//main结束后关闭通道  
go func() {  
    fmt.Println("准备向通道写入")  
    ch <- 1  
    fmt.Println("写入完毕")  
}()  
fmt.Println("准备从通道读出")  
data := <-ch  
fmt.Println("读出完毕")  
fmt.Println(data)
```

## 实例

```go
ch := make(chan int)  
  
go func() {  
    for i := 0; i < 5; i++ {  
       ch <- i  
    }  
    close(ch)  
}()  
  
go func() {  
    for {  
       data, ok := <-ch  
       if !ok {  
          fmt.Println("管道空了")  
          break  
       } else {  
          fmt.Println(data)  
       }  
    }  
}()  
time.Sleep(time.Second)  
fmt.Println("Main to End")
```

```go
ch := make(chan int)  
  
go func() {  
    for i := 0; i < 5; i++ {  
       ch <- i  
    }  
    close(ch)  
}()  
  
go func() {  
    for data := range ch {  
       fmt.Println(data)  
    }  
}()  
time.Sleep(time.Second)  
fmt.Println("Main to End")
```

# WaitGroup同步
由于主线程不会等待协程运行完毕再退出，为了保证所有协程都能运行完毕，可以使用WaitGroup

```go
package main  
  
import (  
    "fmt"  
    "strconv"    "sync")  
  
var wg sync.WaitGroup  
  
func show(msg string) {  
    defer wg.Done() //show运行完毕后协程池数量-1  
    fmt.Println(msg)  
}  
  
func main() {  
    for i := 0; i < 5; i++ {  
       wg.Add(1) //协程池数量+1  
       go show("This is " + strconv.Itoa(i))  
    }  
    wg.Wait() //等待协程池数目为0后再运行下面的代码  
    fmt.Println("All finished")  
    fmt.Println("main exit")  
}
//This is 4  
//This is 3  
//This is 0  
//This is 2  
//This is 1  
//All finished  
//main exit
```