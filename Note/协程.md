⼀个进程可以拥有多个线程，⼀个线程也，可以拥有多个协程，因此协程⼜称微线程和纤程。go中的协程与线程类似，但是其属于用户态，用户可控，线程属于内核态，用户不可控。系统对主线程和协程进行抢占式调度，默认情况下主线程不会等待协程运行完毕才退出，而是主线程结束直接结束协程

```go
package main  
  
import (  
    "fmt"  
    "time")  
  
func show(msg string) {  
    for i := 0; i < 5; i++ {  
       fmt.Println(msg)  
    }  
}  
  
func main() {  
    go show("hello")  
    time.Sleep(1 * time.Second)  
    show("hello world")  
  
}
```

# 通道
通道用于并发执行时，goroutine之间的资源共享，通道分为无缓冲通道和缓冲通道，无缓冲通道用于同步通信，而缓冲通道用于异步通信
## 创建和使用通道

```go
//无缓冲整型通道
ch := make(chan int)  
//缓冲通道
ints := make(chan int, 5)
//使用
ch := make(chan int, 5)  
ch <- 1  
data := <-ch  
fmt.Println(data)
```

## 无缓冲实例

```go
ch := make(chan int)  
go func() {  
    fmt.Println("准备向通道写入")  
    ch <- 1  
    fmt.Println("写入完毕")  
}()  
fmt.Println("准备从通道读出")  
data := <-ch  
fmt.Println("读出完毕")  
fmt.Println(data)
//准备从通道读出  
//准备向通道写入  
//写入完毕  
//读出完毕  
//1

```

## 缓存实例

```go
ch := make(chan int, 1)  
defer close(ch)//main结束后关闭通道  
go func() {  
    fmt.Println("准备向通道写入")  
    ch <- 1  
    fmt.Println("写入完毕")  
}()  
fmt.Println("准备从通道读出")  
data := <-ch  
fmt.Println("读出完毕")  
fmt.Println(data)
```

## 实例

```go
ch := make(chan int)  
  
go func() {  
    for i := 0; i < 5; i++ {  
       ch <- i  
    }  
    close(ch)  
}()  
  
go func() {  
    for {  
       data, ok := <-ch  
       if !ok {  
          fmt.Println("管道空了")  
          break  
       } else {  
          fmt.Println(data)  
       }  
    }  
}()  
time.Sleep(time.Second)  
fmt.Println("Main to End")
```

```go
ch := make(chan int)  
  
go func() {  
    for i := 0; i < 5; i++ {  
       ch <- i  
    }  
    close(ch)  
}()  
  
go func() {  
    for data := range ch {  
       fmt.Println(data)  
    }  
}()  
time.Sleep(time.Second)  
fmt.Println("Main to End")
```

# WaitGroup同步
由于主线程不会等待协程运行完毕再退出，为了保证所有协程都能运行完毕，可以使用WaitGroup

```go
package main  
  
import (  
    "fmt"  
    "strconv"    "sync")  
  
var wg sync.WaitGroup  
  
func show(msg string) {  
    defer wg.Done() //show运行完毕后协程池数量-1  
    fmt.Println(msg)  
}  
  
func main() {  
    for i := 0; i < 5; i++ {  
       wg.Add(1) //协程池数量+1  
       go show("This is " + strconv.Itoa(i))  
    }  
    wg.Wait() //等待协程池数目为0后再运行下面的代码  
    fmt.Println("All finished")  
    fmt.Println("main exit")  
}
//This is 4  
//This is 3  
//This is 0  
//This is 2  
//This is 1  
//All finished  
//main exit
```

# Runtime

`runtime.Gosched()`从主线程将CPU时间片让出给协程运行 
```go
func show(msg string) {  
    for i := 0; i < 2; i++ {  
       fmt.Println(msg)  
    }  
}  
  
func main() {  
    go show("Go")  
  
    runtime.Gosched()  
    fmt.Println("main end")  
}
```

`runtime.Goexit()`退出当前协程
```go
func show(msg string) {  
    for i := 0; i < 10; i++ {  
       fmt.Println(msg)  
       if i > 5 {  
          runtime.Goexit()  
       }  
    }  
}  
  
func main() {  
    go show("Go")  
  
    runtime.Gosched()  
    fmt.Println("main end")  
}
```

# 互斥锁

多个协程对同一变量进行操作，会使得该变量具有不确定性，所以需要使用互斥锁，让A协程访问x变量时，B协程无法访问x，待A释放锁后，B协程才能访问x
```go
var (  
    x    int = 100  
    wg   sync.WaitGroup  
    lock sync.Mutex  
) //}  
  
func Add() {  
    defer wg.Done()  
    lock.Lock()  
    x = x + 1  
    fmt.Printf("x++: %d\n", x)  
    lock.Unlock()  
}  
  
func Sub() {  
    defer wg.Done()  
    lock.Lock()  
    x = x - 1  
    fmt.Printf("x--: %d\n", x)  
    lock.Unlock()  
}  
  
func main() {  
    for i := 0; i < 20; i++ {  
       wg.Add(1)  
       go Add()  
       wg.Add(1)  
       go Sub()  
    }  
    wg.Wait()  
    fmt.Println("main exit")  
}
//x--: 99  
//x--: 98  
//x++: 99  
//x++: 100  
//x--: 99  
//x++: 100  
//x--: 99  
//x--: 98  
//x++: 99  
//x++: 100  
//main exit
```

# 作业

扫描1-65535全端口

写两个版本，一个使用WaitGroup，一个使用通道

连接代码:

```Go

    address := fmt.Sprintf("%s:%d", hostname, port)  //ip端口

    conn, err := net.DialTimeout("tcp", address, 2*time.Second) //2秒

```


```go
package main  
  
import (  
    "fmt"  
    "net"    "sort"    "sync"    "time")  
  
var (  
    open []int  
    wg   sync.WaitGroup  
    lock sync.Mutex  
)  
  
func Detec(hostname string, port int) {  
    defer wg.Done()  
    address := fmt.Sprintf("%s:%d", hostname, port)  
    conn, _ := net.DialTimeout("tcp", address, 2*time.Second)  
    if conn != nil {  
       lock.Lock()  
       open = append(open, port)  
       lock.Unlock()  
    }  
}  
  
func main() {  
    fmt.Println("开始扫描")  
    for i := 1; i <= 65535; i++ {  
       wg.Add(1)  
       go Detec("127.0.0.1", i)  
    }  
  
    sort.Ints(open)  
    fmt.Printf("Port\tStatus\n")  
    for _, v := range open {  
       if v < 1000 {  
          fmt.Printf("%d  \tOPEN\n", v)  
       } else {  
          fmt.Printf("%d\tOPEN\n", v)  
       }  
    }  
    fmt.Println("扫描结束")  
}
```

思考如何控制并发数量，定义`ch   = make(chan int, 3)`用缓冲区通道来限制并发数量

```go
package main  
  
import (  
    "fmt"  
    "net"    "sort"    "sync"    "time")  
  
var (  
    open []int  
    ch   = make(chan int, 3)  
    lock sync.Mutex  
    wg   sync.WaitGroup  
)  
  
func Detec(hostname string, port int) {  
    defer wg.Done()  
    address := fmt.Sprintf("%s:%d", hostname, port)  
    conn, _ := net.DialTimeout("tcp", address, 2*time.Second)  
    if conn != nil {  
       lock.Lock()  
       open = append(open, port)  
       lock.Unlock()  
    }  
    <-ch  
}  
  
func main() {  
    fmt.Println("开始扫描")  
    for i := 1; i <= 65535; i++ {  
       ch <- 1  
       wg.Add(1)  
       go Detec("127.0.0.1", i)  
    }  
    wg.Wait()  
    sort.Ints(open)  
    fmt.Printf("Port\tStatus\n")  
    for _, v := range open {  
       if v < 1000 {  
          fmt.Printf("%d  \tOPEN\n", v)  
       } else {  
          fmt.Printf("%d\tOPEN\n", v)  
       }  
    }  
    fmt.Println("扫描结束")  
}
```

思考如何只是使用channal实现

```go
package main  
  
import (  
    "fmt"  
    "net"
	"sort"
	"sync"
	"time")  
  
var (  
    lock sync.Mutex  
)  
  
func main() {  
    var open []int  
    ch := make(chan int, 3)  
    fmt.Println("开始扫描")  
    for i := 1; i <= 65535; i++ {  
       ch <- 1  
       go func(hostname string, port int) {  
          address := fmt.Sprintf("%s:%d", hostname, port)  
          conn, _ := net.DialTimeout("tcp", address, 2*time.Second)  
          if conn != nil {  
             lock.Lock()  
             open = append(open, port)  
             lock.Unlock()  
          }  
          <-ch  
       }("127.0.0.1", i)  
    }  
    close(ch)  
    sort.Ints(open)  
    fmt.Printf("Port\tStatus\n")  
    for _, v := range open {  
       if v < 1000 {  
          fmt.Printf("%d  \tOPEN\n", v)  
       } else {  
          fmt.Printf("%d\tOPEN\n", v)  
       }  
    }  
    fmt.Println("扫描结束")  
}
```

思考如何添加命令行参数

```go
package main  
  
import (  
    "flag"  
    "fmt"    "net"    "sort"    "strconv"    "strings"    "sync"    "time")  
  
var (  
    lock sync.Mutex  
)  
  
func main() {  
    hostname := flag.String("host", "127.0.0.1", "target hostname")  
    ports := flag.String("ports", "1-65535", "target ports")  
    threads := flag.Int("threads", 5, "number of threads")  
    flag.Parse()  
    split := strings.Split(*ports, "-")  
    start, _ := strconv.Atoi(split[0])  
    end, _ := strconv.Atoi(split[1])  
  
    var open []int  
    ch := make(chan int, *threads)  
    fmt.Println("开始扫描")  
    for i := start; i <= end; i++ {  
       ch <- 1  
       go func(hostname string, port int) {  
          address := fmt.Sprintf("%s:%d", hostname, port)  
          conn, _ := net.DialTimeout("tcp", address, 2*time.Second)  
          if conn != nil {  
             lock.Lock()  
             open = append(open, port)  
             lock.Unlock()  
          }  
          <-ch  
       }(*hostname, i)  
    }  
    close(ch)  
    sort.Ints(open)  
    fmt.Printf("Port\tStatus\n")  
    for _, v := range open {  
       if v < 1000 {  
          fmt.Printf("%d  \tOPEN\n", v)  
       } else {  
          fmt.Printf("%d\tOPEN\n", v)  
       }  
    }  
    fmt.Println("扫描结束")  
}
//-host 127.0.0.1 -ports 1-10000 -threads=3

```